"""
Adapter to make StrategySelector compatible with BacktestEngine's Strategy interface.
"""
from typing import Optional
import pandas as pd
import logging

from cthulu.strategy.base import Strategy, Signal
from cthulu.strategy.strategy_selector import StrategySelector


class StrategySelectorAdapter(Strategy):
    """Wrap a StrategySelector and expose the Strategy interface expected by BacktestEngine.

    It accumulates recent bars into a small DataFrame and passes both the DataFrame
    and the latest bar into the underlying selector.generate_signal method.
    """

    def __init__(self, selector: StrategySelector, name: Optional[str] = None, max_history: int = 500):
        super().__init__(name or f"dynamic_selector_{id(selector)}", config={})
        self.logger = logging.getLogger("Cthulu.strategy.selector_adapter")
        self.selector = selector
        self.max_history = max_history
        self._bars = []  # list of dict rows to build DataFrame

    def on_bar(self, bar: pd.Series) -> Optional[Signal]:
        # Append latest bar to history
        try:
            ts = getattr(bar, "name", None)
            row = bar.to_dict()
            if ts is not None:
                row["_timestamp"] = ts
            self._bars.append(row)
            if len(self._bars) > self.max_history:
                self._bars.pop(0)

            data = pd.DataFrame(self._bars)
            if "_timestamp" in data.columns:
                try:
                    data = data.set_index("_timestamp")
                except Exception:
                    pass

            # Delegate to underlying selector
            signal = self.selector.generate_signal(data, bar)
            if signal:
                # Mark signal as generated by selector for traceability
                signal.metadata.setdefault("generated_by", self.selector.current_strategy.name if self.selector.current_strategy else self.name)
            return signal
        except Exception as e:
            self.logger.error(f"Selector adapter on_bar failed: {e}")
            return None

    def reset(self):
        self._bars.clear()
        # If underlying selector has reset, call it
        if hasattr(self.selector, "reset"):
            try:
                self.selector.current_strategy = None
            except Exception:
                pass

    def configure(self, params: dict):
        # Propagate to underlying selector config if possible
        if isinstance(self.selector, StrategySelector) and isinstance(params, dict):
            self.selector.config.update(params)
            self.logger.info("StrategySelectorAdapter reconfigured underlying selector")
        else:
            self.logger.debug("StrategySelectorAdapter received configure request")
